;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*              MODIFICAÇÕES PARA USO COM 12F675                   *
;*                FEITAS PELO PROF. MARDSON                        *
;*                    FEVEREIRO DE 2016                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       NOME DO PROJETO                           *
;*                           CLIENTE                               *
;*         DESENVOLVIDO PELA MOSAICO ENGENHARIA E CONSULTORIA      *
;*   VERSÃO: 1.0                           DATA: 17/06/03          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     DESCRIÇÃO DO ARQUIVO                        *
;*-----------------------------------------------------------------*
;*   MODELO PARA O PIC 12F675                                      *
;**    Espaço reservado para descrição funcional do projeto        *
;* está atividade é destinada ao desenvolvimento de um conversor A/D *
;junto com um diplay que vai verificar em % da tenção aplicada no mesmo	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ARQUIVOS DE DEFINIÇÕES                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
#INCLUDE <p12f675.inc>	;ARQUIVO PADRÃO MICROCHIP PARA 12F675

	__CONFIG _BODEN_OFF & _CP_OFF & _PWRTE_ON & _WDT_OFF & _MCLRE_ON & _INTRC_OSC_NOCLKOUT

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    PAGINAÇÃO DE MEMÓRIA                         *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;DEFINIÇÃO DE COMANDOS DE USUÁRIO PARA ALTERAÇÃO DA PÁGINA DE MEMÓRIA
#DEFINE	BANK0	BCF STATUS,RP0	;SETA BANK 0 DE MEMÓRIA
#DEFINE	BANK1	BSF STATUS,RP0	;SETA BANK 1 DE MAMÓRIA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         VARIÁVEIS                               *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DOS NOMES E ENDEREÇOS DE TODAS AS VARIÁVEIS UTILIZADAS 
; PELO SISTEMA

	CBLOCK	0x20	;ENDEREÇO INICIAL DA MEMÓRIA DE
					;USUÁRIO
		W_TEMP		;REGISTRADORES TEMPORÁRIOS PARA USO
		STATUS_TEMP	;JUNTO ÀS INTERRUPÇÕES

		TEMP0;VERIAVEL AUXILIAR PARA TEMPORALIZAÇÃO
		ADC;REGISTRADOR USADO PARA COMPRAÇÃO
	;** REGISTRADORES UTILIZADOS NAS ROTINAS DE MULTIPLICAÇÃO E DIVISÃÃO***	
		A0						;**************
		B0						;**************
		C0						;**************
		C1						;**************
	;**********************************************************************
		SOMA;VARIAVEL UTILIZADA PARA A SOMA DAS TENSÕES DE ENTRADA 
		SOMA2
		AUX;VARIAVEL USADA PARA DECREMENTAR O LOOP DA SOMA 
		AUX2
		AUX3
		RODA;VERIAVEL USADA PARA RODAR O CONTEUDO DE C1(QUE É CALCULADO NA REGRA DE 3)
		DEZENA
		UNIDADE
	ENDC			;FIM DO BLOCO DE MEMÓRIA
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                        FLAGS INTERNOS                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS FLAGS UTILIZADOS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                         CONSTANTES                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODAS AS CONSTANTES UTILIZADAS PELO SISTEMA

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           ENTRADAS                              *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO ENTRADA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)
	#DEFINE	    PORTA   GPIO,GP2	;DEFININDO A PORTA GP2 COMO ENTRADA
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                           SAÍDAS                                *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; DEFINIÇÃO DE TODOS OS PINOS QUE SERÃO UTILIZADOS COMO SAÍDA
; RECOMENDAMOS TAMBÉM COMENTAR O SIGNIFICADO DE SEUS ESTADOS (0 E 1)
	#DEFINE	    LCD_EN	GPIO,GP5;HABILITA O SINAL DE LEITURA E ESCRITA DO LCD
	;QUANDO ALGO FOR MANDADO PARA O LCD É PRECISO DEIXAR ELE ALTO PARA QUE O LCD POSSA RECEBER OS DADOS 
	#DEFINE	    SRDAT	GPIO,GP4;É RESPONSAVEL PELO DADO QUE SERÁ ENVIADO PARA O
	#DEFINE	    SRCLK	GPIO,GP0;RESPONSAVEL PELO CLOCK Q SERÁ ENVIADO PARA O SHIFT(REGISTRADOR)
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       VETOR DE RESET                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	ORG	0x00			;ENDEREÇO INICIAL DE PROCESSAMENTO
	GOTO	INICIO
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    INÍCIO DA INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; ENDEREÇO DE DESVIO DAS INTERRUPÇÕES. A PRIMEIRA TAREFA É SALVAR OS
; VALORES DE "W" E "STATUS" PARA RECUPERAÇÃO FUTURA

	ORG	0x04			;ENDEREÇO INICIAL DA INTERRUPÇÃO
	MOVWF	W_TEMP		;COPIA W PARA W_TEMP
	SWAPF	STATUS,W
	MOVWF	STATUS_TEMP	;COPIA STATUS PARA STATUS_TEMP

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                    ROTINA DE INTERRUPÇÃO                        *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; AQUI SERÁ ESCRITA AS ROTINAS DE RECONHECIMENTO E TRATAMENTO DAS
; INTERRUPÇÕES

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                 ROTINA DE SAÍDA DA INTERRUPÇÃO                  *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; OS VALORES DE "W" E "STATUS" DEVEM SER RECUPERADOS ANTES DE 
; RETORNAR DA INTERRUPÇÃO

SAI_INT
	SWAPF	STATUS_TEMP,W
	MOVWF	STATUS		;MOVE STATUS_TEMP PARA STATUS
	SWAPF	W_TEMP,F
	SWAPF	W_TEMP,W	;MOVE W_TEMP PARA W
	RETFIE

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*	            	 ROTINAS E SUBROTINAS                      *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
; CADA ROTINA OU SUBROTINA DEVE POSSUIR A DESCRIÇÃO DE FUNCIONAMENTO
; E UM NOME COERENTE ÀS SUAS FUNÇÕES.
;*******************ROTINA DE MULTIPLICAÇÃO*******************************
MULTPLICACAO
	CLRF	C0;LIMPA O REGISTRADOR C0
	CLRF	C1;LIMPA REGISTRADOR C1
	MOVF	A0,W;ENVIA O CONTEUDO DE A0 PARA W
	MOVWF	C0;ENVIA O CONTEUDO DE W PARA C0
	
LOOP_M
	DECF	B0,F;DECREMENTA B0
	BTFSC	STATUS,Z;B0 IGUAL A ZERO?
	RETURN		;SIM,RETORNA
	MOVF	A0,W;COPIA A0 PARA W
	ADDWF	C0,F;SOMA A0 COM C0
	BTFSC	STATUS,C;HOUVE ESTOURO DE C0?
	INCF	C1,F	;SIM,INCREMENTA C1
	
	GOTO	LOOP_M
	RETURN
;*******************ROTINA DE DIVISÃO*******************************
DIVSÃO
	CLRF	C0;LIMPA O CONTEUDO DO REGISTRADOR C0
LOOP_D
	MOVF	B0,W
	SUBWF	A0,F;SUBTRAI B0(DIVISOR) POR A0
	BTFSS	STATUS,C;TESTE DE CARRY
	GOTO	LOOP_D_MENOR
	INCF	C0,F;SE O DIVIDENDO É MAIOR QUE O INCREMENTO
	GOTO	LOOP_D
LOOP_D_MENOR
	MOVF	B0,W
	ADDWF	A0,W
	MOVWF	C1;RESTO DA DIVISÃO 
	RETURN
REGRA_D_3
	;SABENDO QUE A ROTINA MULTIPLICAÇÃO FUNCIONA DA SEGUINTE FORma:
	;CO=A0*B0
	;LOGO:	C0=SOMA*B0 QUE IMPLICA: C0=SOMA*100
	MOVLW	.100;PASSA O VALOR DA PORCENTAGEM 100% PARA B0
	MOVWF	B0
	MOVFW	SOMA;TRANSFERE O CONTEUDO DE SOMA PARA A0
	MOVWF	A0
	CALL	MULTPLICACAO;CHAMA A ROTINA DE MULTIPLICAÇÃO
	
	RETURN
DELAY_100US
	MOVLW	.231	;(256-25=231)
	MOVWF	TMR0; 25*4=100US
	BCF INTCON,T0IF; ZERA O T0IF POR SEGURANÇA
VOLTA1
	BTFSS	INTCON,T0IF;LOOP QUE ESPERA SETAR O T0IF
	GOTO	VOLTA1
	NOP
	NOP
	NOP
	RETURN
;COMO NOS DEFINIMOS O VALOR 10? DA SEGUINTE FORMA: 40US/(PRESCALER=4)=10
DELAY_40US
	MOVLW	.247	;(256-10=246)
	MOVWF	TMR0;10*4=40 US
	BCF INTCON,T0IF; ZERA O T0IF POR SEGURANÇA
VOLTA2
	BTFSS	INTCON,T0IF;LOOP QUE ESPERA SETAR O T0IF
	GOTO	VOLTA2
	RETURN
DELAY_15MS
	;ZERANDO OS TMR1L E TMR1H
	CLRF	TMR1H
	CLRF	TMR1L
	;COMO NOS DEFINIMOS O VALOR 1875? DA SEGUINTE FORMA: 15000MS/(PRESCALER=8)=1875
	MOVLW	B'11111000'	;(65536-1875)
	MOVWF	TMR1H	;(1875*8=15000)
	MOVLW	B'10101101';PARA ISSO DIVIDE OS 16BITS EM 8 EM CASA 
	MOVWF	TMR1L
	BCF PIR1,TMR1IF;ZERA O TMR1IF POR SEGURANÇA
	BTFSS	PIR1,TMR1IF;LOOP ESPERANDO SETAR O TMR1IF
	GOTO	$-1
	RETURN
DELAY_4MS
	;ZERANDO OS TMR1L E TMR1H
	CLRF	TMR1H
	CLRF	TMR1L
	;COMO NOS DEFINIMOS O VALOR 1875? DA SEGUINTE FORMA: 4000MS/(PRESCALER=8)=500
	MOVLW	B'11111110'	;(65536-500)
	MOVWF	TMR1H	;(500*8=4000)
	MOVLW	B'00001100';PARA ISSO DIVIDE OS 16BITS EM 8 EM CASA 
	MOVWF	TMR1L
	BCF PIR1,TMR1IF;ZERA O TMR1IF POR SEGURANÇA
	BTFSS	PIR1,TMR1IF;LOOP ESPERANDO SETAR O TMR1IF
	GOTO	$-1
	RETURN
DELAY_165MS
	;ZERANDO OS TMR1L E TMR1H
	CLRF	TMR1H
	CLRF	TMR1L
	;COMO NOS DEFINIMOS O VALOR 1875? DA SEGUINTE FORMA: 1650MS/(PRESCALER=8)=207
	MOVLW	B'11111111'	;(65536-207=65329)
	MOVWF	TMR1H	;(207*8=1650)
	MOVLW	B'00110001';PARA ISSO DIVIDE OS 16BITS EM 8 EM CASA 
	MOVWF	TMR1L
	BCF PIR1,TMR1IF;ZERA O TMR1IF POR SEGURANÇA
	BTFSS	PIR1,TMR1IF;LOOP ESPERANDO SETAR O TMR1IF
	GOTO	$-1
	RETURN
;INICIALIZAÇÃO DO LCD
INIT
	;PRIMEIRA INSTRUÇÃO
	
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	
	
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------DELAY--------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;---------------------------segunda instrução-----------------------------------------------------
	
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------DELAY100----------
	CALL	DELAY_100US
	CALL	DELAY_100US
	;----------------TERCEIRA INSTRUÇÃO----------------------------------
	
	
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------DELAY100US---------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;-----------------QUARTA INSTRUÇÃO--------------------------------
	
	
	
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;0 mudeiiiiiiiiiiiiiiiiiiiiii<----------------------
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	
	
	;---------DELAY40US---------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;-------------------QUINTA INSTRUÇÃO---1----------------------
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;--------------------
	;---------------QUINTA INSTRUÇÃO PARTE 2------------------------
	
	;----------DB7-------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------DELAY40US------------
	
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;--------------------SEXTA INSTRUÇÃO-------------------
	
	
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;----------------------
	
	;-------------------------SEXTA INSTRUÇÃO PARTE 2-----------------------
	;----------DB7-------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------40US------------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;--------------------SETIMA INSTRUÇÃO--------------------------
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;---------2MS-------------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;---------------------SETIMA INSTRUÇÃO 2-------------------------
	;----------DB7-------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;-------------------------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;--------------------OITAVA INSTRUÇÃO------------------
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	;----------40US-------------
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	;------------------------ OITAVA INSTRUÇÃO 2----------------------
	;----------DB7-------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;-----------DB6----------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------DB5----------
	BSF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------DB4----------
	BCF	SRDAT;1
	CALL	TIMER_CLOCK
	;----------RS--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------BACK--------
	BSF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	;----------X--------
	BCF	SRDAT;0
	CALL	TIMER_CLOCK
	CALL	ENABLE
	CALL	DELAY_15MS
	CALL	DELAY_15MS
	RETURN
TIMER_CLOCK
	BSF	SRCLK
	BCF	SRCLK
	RETURN
;SUBROTINA DO ESTADO DO ENABLE
ENABLE
	BSF	LCD_EN
	BCF	LCD_EN
	RETURN
ENVIA_CARACTER
	MOVWF	RODA
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4; É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIA VALOR PARA DB7
	CALL	TIMER_CLOCK;
	GOTO	$+3;PULA 3 LINHAS
	BSF	SRDAT ; ENVIANDO O VALOR PARA DB7
	CALL	TIMER_CLOCK;
	
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4; É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIA VALOR PARA DB6
	CALL	TIMER_CLOCK;
	GOTO	$+3;PULA 3 LINHAS
	BSF	SRDAT ;ENVIA VALOR PARA DB6
	CALL	TIMER_CLOCK;
	
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4; É ZERO, ENTÃO PULAMOS 4 LINHAS

	BCF	SRDAT ;  ENVIA VALOR PARA DB5
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ;  ENVIA VALOR PARA DB5
	CALL	TIMER_CLOCK;
	
	RLF	RODA; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ; ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4; É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ;  ENVIA VALOR PARA DB4
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ;  ENVIA VALOR PARA DB4
	CALL	TIMER_CLOCK;
	
	
	BSF	SRDAT ; ENVIANDO VALOR PARA RS
	CALL	TIMER_CLOCK;
	
	BSF	SRDAT;  ENVIANDO VALOR PARA BL
	CALL	TIMER_CLOCK;
	BCF	SRDAT ;  ENVIANDO VALOR PARA X
	CALL	TIMER_CLOCK;
	BCF	SRDAT ;  ENVIANDO VALOR PARA X
	CALL	TIMER_CLOCK;
	
	; SETANDO O VALOR DE  LCD_ENABLE
	CALL	ENABLE;CHAMA A ROTINA DE PULSO DO LCD_ENABLE
	
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ; ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4;É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIANDO VALOR PARA DB7
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ; ENVIANDO VALOR PARA  DB7
	CALL	TIMER_CLOCK;
	
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ; ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4;É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIANDO VALOR PARA DB6
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ; ENVIANDO VALOR PARA DB6
	CALL	TIMER_CLOCK;
	
	RLF	RODA ; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ; ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4; É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIANDO VALOR PARA DB5
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ; ENVIANDO VALOR PARA DB5
	CALL	TIMER_CLOCK;
	
	RLF	RODA; ROTACIONA O VALOR ARMAZENADO EM W(WORK)
	BTFSC	STATUS, C ; ;VERIFICANDO SE O VALOR DO CARRY É ZERO
	GOTO	$+4;É ZERO, ENTÃO PULAMOS 4 LINHAS
	BCF	SRDAT ; ENVIANDO VALOR PARA DB4
	CALL	TIMER_CLOCK;
	GOTO	$+3; PULA 3 LINHAS
	BSF	SRDAT ; ENVIANDO VALOR PARA DB4
	CALL	TIMER_CLOCK;
	
	
	BSF	SRDAT ;  ENVIANDO VALOR PARA RS
	CALL	TIMER_CLOCK;
	
	BSF	SRDAT ;  ENVIANDO VALOR PARA BL(BACK LIGHT)
	CALL	TIMER_CLOCK;
	BCF	SRDAT ;   ENVIANDO VALOR PARA X
	CALL	TIMER_CLOCK;
	BCF	SRDAT ; ENVIANDO VALOR PARA X
	CALL	TIMER_CLOCK;
	
	; setando o valor LCD_ENABLE
	CALL	ENABLE;
		
	RETURN
	; AS ROTINAS A SEGUIR TEM COMO OBJETIVO ESCREVER OS CARACTERES USANDO SEUS RESPECTIVOS CODIGOS ASCII
	;COM A FINALIDADE DE ESCREVER CORRETAMENTE NO LCD
ESCREVE_9
	MOVLW	A'9';CODIGO EM ASCII DO NUMERO 9 
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_8
	MOVLW	A'8';CODIGO EM ASCII DO NUMERO 8
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_7
	MOVLW	A'7';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_6
	MOVLW	A'6';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_5
	MOVLW	A'5';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_4
	MOVLW	A'4';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_3
	MOVLW	A'3';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_2
	MOVLW	A'2';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_1
	MOVLW	A'1';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	return
ESCREVE_0
	MOVLW	A'0';CODIGO EM ASCII DO NUMERO
	CALL	ENVIA_CARACTER;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
ESCREVE_10
	CALL	ESCREVE_1;CHAMA A ROTINA PARA ESCREVER NO LCD
	CALL	ESCREVE_0;CHAMA A ROTINA PARA ESCREVER NO LCD
	RETURN
	
	
	
LOOP_DEZENA
	MOVFW	C1;MOVE O CONTEUDO DE C1 PARA A VARIAVEL A0
	MOVWF	A0
	MOVLW	.10;FAZENDO B0=10
	MOVWF	B0
	CALL	DIVSÃO;CHAMANDO A ROTINA DE DIVISÃO FAZEMOS, C0=A0/C0
	MOVFW	C0;VALOR OBTIVO PELA ROTINA DE DIVISÃO
	MOVWF	DEZENA;PASSANDO O VALOR OBTIDO NA ROTINA DE DIVISÃO PARA A VARIAVEL DEZENA
	MOVLW	.10;MOVENDO 10 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_10;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.9	 ; MOVENDO 9 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_9;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.8	; ; MOVENDO 8 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_8;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.7	  ; MOVENDO 7 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_7;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.6	; ; MOVENDO 6 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_6;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.5	; ; MOVENDO 5 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_5;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.4	  ; ; MOVENDO 4 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_4;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.3	 ; MOVENDO 3 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_3;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.2	; ; MOVENDO 2 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_2;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.1	 ; MOVENDO 1 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_1;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.0	; ; MOVENDO 0 PARA W(WORK)
	SUBWF	DEZENA,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_0;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	RETURN
LOOP_UNIDADE
	MOVFW	C1;PEGA O RESTO DA DIVISÃO POR 10 DA ROTINA ANTERIOR
	MOVWF	UNIDADE;JOGA ESSE VALOR NA VARIAVEL UNIDADE
	MOVLW	.0 ; MOVENDO 0 PARA W(WORK)
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_0;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.1
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_1;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.2
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_2;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.3
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_3;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.4
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_4;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.5
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_5;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.6
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_6;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.7
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_7;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.8
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_8;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	MOVLW	.9
	SUBWF	UNIDADE,W;FAZENDO A SUBTRAÇÃO ENTRA AS VARIAVEIS DEZENA E WORK (W=DEZENA-W)
	BTFSC	STATUS,Z;VERIFICA SE A SUBTRAÇÃO DEU ZERO
	CALL	ESCREVE_9;CASO TENHA DADO ZERO,ESCREVE O CARACTER NA TELA DO LCD
	
	RETURN
	
	
;*******************ROTINA DA MEDIA*******************************

	
	

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIO DO PROGRAMA                          *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
INICIO
	BANK1				;ALTERA PARA O BANCO 1
	MOVLW	B'00000100' ;HABILITANDO GP2 COMO PORTA DE ENTRADA E AS DEMAIS COMO SAIDA
	MOVWF	TRISIO		
	MOVLW	B'00010100';DEFININDO UM CLOCK DE FOSC/8 E CONFIGURA ANS2 PARA UTLIZAÇÃO
	MOVWF	ANSEL 		;DEFINE PORTAS COMO Digital I/O
	MOVLW	B'00000001' ;definindo prescale de 1:4
	MOVWF	OPTION_REG	;DEFINE OPÇÕES DE OPERAÇÃO
	MOVLW	B'00000000'
	MOVWF	INTCON		;DEFINE OPÇÕES DE INTERRUPÇÕES
	BANK0				;RETORNA PARA O BANCO
	MOVLW	B'00000111'
	MOVWF	CMCON		;DEFINE O MODO DE OPERAÇÃO DO COMPARADOR ANALÓGICO
	MOVLW	B'00110001' ;DEFININDO O PRESCALER DE 1;8 NO TIMER1 (BITS 4 E 5)
	MOVWF	T1CON	;REGISTRADOR DE CONTROLE DO TIMER1
	MOVLW	B'00001001'
	MOVWF	PIR1
	MOVLW	B'00001001';CONFIGURANDO DO AN2(CANAL ANALOGICO) E ADON(STATUS DE CONVERSÃO) 
	MOVWF	ADCON0
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     INICIALIZAÇÃO DAS VARIÁVEIS                 *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     ROTINA PRINCIPAL                            *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
			
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                     REALIZANDO A CONVERSÃO			   *
;*O BIT GO_DONE SINALIZA SE A CONVERSÃO FOI REALIZADA		   *
;*O PROPRIO MICROCONTROLADOR SETA ESSE BIT PARA ZERO QUANDO	   * 
;*A CONVERSÃO ESTIVER FINALIZADO				   *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
	
MAIN
	MOVLW	.32
	MOVWF	AUX;MOVE O CONTEUDO PRESENTE EM WORK PARA A VARIAVEL AUX, OU SEJA AUX=32
	CLRF	SOMA;LIMPANDO SOMA
	CLRF	SOMA2;LIMPANDO SOMA
LOOP	;COLOCANDO O GO_DONE EM UM INICIALIZAMOS O PROCESSO DE CONVERSAO A/D
	CLRF	ADRESH
	CALL	DELAY_40US;DELAY PRA GARANTIR
	BSF	ADCON0,GO_DONE	;RECEBENDO UM DADO DO CANAL ANALOGICO
	CALL	DELAY_40US;DELAY PRA GARANTIR
AGUARDA_CONVERSAO
	BTFSC	ADCON0,GO_DONE; O DADO ESTÁ PRONTO?
	GOTO	AGUARDA_CONVERSAO;NÃO
	MOVF	ADRESH,W;O VALOR DA CONVERSÃO É CARREGADO NO REGISTRADOR WORK
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*   PARA FINS DE PRECISÃO NO CALCULO DA TENSÃO NESTE CONVERSOR	   *
;*FAREMOS A AQUISIÇÃO DA TENSÃO CONVERTIDA 32 VEZES E EM	   *
;*SEGUIDA O CALCULO DE UMA MEDIA				   * 
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	
	
	ADDWF	SOMA,1
	BTFSC	STATUS,C;HOUVE ESTOURO DE SOMA?
	INCF	SOMA2,F	;SIM,INCREMENTA SOMA2
	DECFSZ	AUX ;É ZERO?
	GOTO	LOOP;NÃO
	;GOTO	MEDIA;SIM
MEDIA
	;NESTE MOMENTO ROTACIONAMMOS 5VEZES AS VARIAVEIS SOMA E SOMA2 RESPECTIVAMENTE
	;COM ISSO OBTERMOS A MEDIA DA TENÇÃO DE ENTRADA
	RRF	SOMA2,1;ROTACIONANDO A VARIAVEL SOMA2 E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA,1;ROTACIONANDO A VARIAVEL SOMA E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA2,1;ROTACIONANDO A VARIAVEL SOMA2 E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA,1;ROTACIONANDO A VARIAVEL SOMA E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA2,1;ROTACIONANDO A VARIAVEL SOMA2 E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA,1;ROTACIONANDO A VARIAVEL SOMA E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA2,1;ROTACIONANDO A VARIAVEL SOMA2 E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA,1;ROTACIONANDO A VARIAVEL SOMA E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA2,1;ROTACIONANDO A VARIAVEL SOMA2 E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS
	RRF	SOMA,1;ROTACIONANDO A VARIAVEL SOMA E ARMAZENANDO NA MESMA OS VALORES ROTACIONADOS


	CALL	REGRA_D_3;CHAMANDO A ROTINA DE CALCULO DA REGRA DE 3, QUE NOS AJUDA A OBTER O VALOR EM
			 ;PORCENTAGEM (%) DA TENSÃO DE ENTRADA, ESTA ROTINA RETORNA SUA RESPOSTA
			 ;NA VARIAVEL C1
	CALL	INIT;INICIALIZAÇÃO DO LCD
	MOVFW	C1;PASSA O CONTEUDO DE C1 PARA WORK(W)
	CALL	LOOP_DEZENA;SEPARA O CONTEUDO DA VARIAVEL C1 EM DEZENA E 
	CALL	LOOP_UNIDADE;UNIDADE RESPECTIVAMENTE EX: 22%->DEZENA=2, UNIDADE=2
	movlw	'%'	    ;ENVIA O VALOR % PARA W(WORK)
	call	ENVIA_CARACTER;CHAMA A ROTINA QUE ESCREVE OS CARACTERES NO LCD, NESTE CASO ESCREVE % NO LCD
	call	DELAY_165MS;AGUARDA 200ms PRA ATUALIZAR O LCD NOVAMENTE
	call	DELAY_15MS;
	call	DELAY_15MS;
	call	DELAY_4MS;
	
	

  	GOTO MAIN

;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
;*                       FIM DO PROGRAMA                           *
;* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

	END



